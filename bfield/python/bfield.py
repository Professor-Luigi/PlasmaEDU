import numpy as np
import scipy.special as special


def loopbrz( Ra, I0, Nturns, R, Z ):
    # Input
    #     Ra [m]      Loop radius
    #     I0 [A]      Loop current
    #     Nturns      Loop number of turns (windings)
    #     R  [m]      Radial coordinate of the point
    #     Z  [m]      Axial  coordinate of the point
    # Output
    #     Br, Bz [T]  Radial and Axial components of B-field at (R,Z)
    #
    # (Note that singularities are not handled here)
    mu0   = 4.0e-7 * np.pi
    B0    = mu0/2.0/Ra * I0 * Nturns
    alfa  = np.absolute(R)/Ra
    beta  = Z/Ra
    gamma = Z/(R+1.0e-10)
    Q     = (1+alfa)**2 + beta**2
    ksq   = 4.0 * alfa / Q
    asq   = alfa * alfa
    bsq   = beta * beta
    Qsp   = 1.0/np.pi/np.sqrt(Q)
    K     = special.ellipk(ksq)
    E     = special.ellipe(ksq)
    Br    = gamma * B0*Qsp * ( E * (1+asq+bsq)/(Q-4.0*alfa) - K )
    Bz    =         B0*Qsp * ( E * (1-asq-bsq)/(Q-4.0*alfa) + K )
    return Br, Bz


def roto(Nhat):
    # Obtain rotation matrix ROT from unit vector Nhat
    Nx    = Nhat[0]
    Ny    = Nhat[1]
    Nz    = Nhat[2]
    Nxy   = np.sqrt( Nx*Nx + Ny*Ny )
    Nnorm = np.sqrt( Nx*Nx + Ny*Ny + Nz*Nz )
    cth   = Nx/Nxy
    sth   = Ny/Nxy
    cphi  = Nxy/Nnorm
    sphi  = Nz/Nnorm
    R0 = np.array([[0,0,1],[1,0,0],[0,1,0]])
    R1 = np.array([[cphi,0,sphi],[0,1,0],[-sphi,0,cphi]])
    R2 = np.array([[cth,sth,0],[-sth,cth,0],[0,0,1]])
    ROT = (R0.dot(R1)).dot(R2)
    return ROT


def loopxyz( Ra, I0, Nturns, Center, Uhat, Point ):
    # This function returns the 3 Cartesian components B=(Bx,By,Bz) of the
    # magnetic field at the point Point(Xp,Yp,Zp) generated by a current loop
    # arbitrarily oriented in the 3D space.
    #
    # Input
    #           Ra  :  Loop Radius [m]
    #           I0  :  Loop Current [A]
    #       Nturns  :  Loop number of turns
    #
    # Center = (Xc, Yc, Zc)  :  Position [m] of the Center of the Current Loop,
    #                            expressed in the LAB Reference Frame
    #
    # Uhat = (Ux, Uy, Uz)    :  Orientation of the Current Loop, given by a
    #                            vector normal to the surface of the loop,
    #                            expressed in the LAB Reference Frame;
    #                            if the vector provided is not a unit vector,
    #                            than Uhat is normalized.
    #
    # Point = (Xp, Yp, Zp)   : Position of interest, defined as the
    #                           segment OP, where O is the origin of the
    #                           LAB Reference Frame, and P the point where
    #                           the magnetic field has to be found
    # Output
    #
    #     Magnetic field vector expressed in the LAB Reference Frame
    #
    #     Bx       X component of the B-field generated by the Current Loop
    #     By       Y component of the B-field generated by the Current Loop
    #     Bz       Z component of the B-field generated by the Current Loop
    #
    # If Uhat is not a unit vector yet, than normalize it
    Unorm = np.sqrt( Uhat[0]*Uhat[0] + Uhat[1]*Uhat[1] + Uhat[2]*Uhat[2] )
    if (Unorm != 1.0):
        Uhat[0] = Uhat[0]/Unorm
        Uhat[1] = Uhat[1]/Unorm
        Uhat[2] = Uhat[2]/Unorm
    # Rotation matrix from LAB Reference Frame to LOOP Reference Frame
    ROT_LAB_LOOP = roto(Uhat)
    # Roto-traslation of the point P into the LOOP reference frame
    P_LOOP = ROT_LAB_LOOP.dot( Point - Center )
    R = P_LOOP[2]
    Z = P_LOOP[1]
    # Magnetic field in the LOOP Reference Frame
    Br, Bz = loopbrz( Ra, I0, Nturns, R, Z )
    B_LOOP = np.array([Br, 0.0, Bz])
    # Rotate the magnetic field from LOOP Reference Frame to LAB Reference Frame
    ROT_LOOP_LAB = np.transpose(ROT_LAB_LOOP)
    B_LAB  = ROT_LOOP_LAB.dot(B_LOOP)
    Bx = B_LAB[0]
    By = B_LAB[1]
    Bz = B_LAB[2]
    return Bx, By, Bz


def makeloop( Ra, Center, Uhat, Npoints ):
    # Construct the geometrical points of a loop
    #
    # Input
    #
    # Ra  :  Loop Radius [m]
    #
    # Center = (Xc, Yc, Zc)  :  Position [m] of the Center of the Current Loop,
    #                            expressed in the LAB Reference Frame
    #
    # Uhat = (Ux, Uy, Uz)    :  Orientation of the Current Loop, given by a
    #                            vector normal to the surface of the loop,
    #                            expressed in the LAB Reference Frame;
    #                            if the vector provided is not a unit vector,
    #                            than Uhat is normalized.
    # Npoint : Number of discrete points
    #
    # Output
    #
    # CurrentFilament   :  (3 x Npoint) Array containing the 3D coordinates of
    #                      the points of the current loop
    CurrentFilament = np.zeros((3,Npoints))
    # Rotation matrix from LAB Reference Frame to LOOP Reference Frame
    ROT_LAB_LOOP = roto(Uhat)
    # Rotation matrix from LOOP Reference Frame to LAB Reference Frame
    ROT_LOOP_LAB = np.transpose(ROT_LAB_LOOP)
    # Construct the coordinates of the Loop
    P_LOOP   = np.zeros((3,1))
    phi = np.linspace(0.0, 2.0*np.pi, Npoints)
    for i in range(0,Npoints):
        P_LOOP[0] =  Ra * np.cos( phi[i] )
        P_LOOP[1] =  0.0
        P_LOOP[2] = -Ra * np.sin( phi[i] )
        P_LAB = ROT_LOOP_LAB.dot( P_LOOP )
        CurrentFilament[0][i] = P_LAB[0] + Center[0]
        CurrentFilament[1][i] = P_LAB[1] + Center[1]
        CurrentFilament[2][i] = P_LAB[2] + Center[2]
    return CurrentFilament


def biotsavart( filament, current, point ):
    Npoints = np.size(filament,1)
    B = np.zeros((3,1))
    for i in range(Npoints-1):
        P1 = filament[:,i  ]
        P2 = filament[:,i+1]
        dl = P2 - P1
        midpoint = 0.5 * (P1 + P2)
        R  = np.transpose(point) - midpoint
        Rm = np.sqrt( R[0,0]*R[0,0] + R[0,1]*R[0,1] + R[0,2]*R[0,2] )
        R3 = Rm * Rm * Rm + 1.0e-12
        dI = current * dl
        dB = 1.0e-7 * np.cross(dI,R) / R3
        B[0] += dB[0,0]
        B[1] += dB[0,1]
        B[2] += dB[0,2]
    return B[0], B[1], B[2]


def blines(y,x, filament, current):
    X=y[0]
    Y=y[1]
    Z=y[2]
    direction=y[3]
    point = np.array([ [X], [Y], [Z] ])
    B     = biotsavart( filament, current, point )
    Bnorm = np.sqrt(B[0]*B[0] + B[1]*B[1] + B[2]*B[2])
    dY    = np.zeros(4)
    dY[0] = direction * B[0]/Bnorm
    dY[1] = direction * B[1]/Bnorm
    dY[2] = direction * B[2]/Bnorm
    dY[3] = 0.0
    return dY
